-- Weekly reports (Habits + Weight + Medication)
-- Timezone baseline for report windows: Europe/Madrid

create table if not exists public.weekly_reports (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  generated_at timestamptz not null default now(),
  week_start date not null,
  week_end date not null,
  payload_json jsonb not null,
  summary_text text not null,
  created_at timestamptz not null default now(),
  unique (user_id, week_start),
  check (week_end >= week_start)
);

create index if not exists weekly_reports_user_week_idx
on public.weekly_reports (user_id, week_start desc);

alter table public.weekly_reports enable row level security;

drop policy if exists weekly_reports_select_own on public.weekly_reports;
create policy weekly_reports_select_own
on public.weekly_reports
for select
using (auth.uid() = user_id);

drop policy if exists weekly_reports_insert_own on public.weekly_reports;
create policy weekly_reports_insert_own
on public.weekly_reports
for insert
with check (auth.uid() = user_id);

create or replace function public.weekly_report_period(
  p_reference timestamptz default now(),
  p_tz text default 'Europe/Madrid'
)
returns table (
  local_reference timestamp,
  week_start date,
  week_end date,
  prev_week_start date,
  prev_week_end date
)
language sql
stable
as $$
  with x as (
    select (p_reference at time zone p_tz) as local_ref
  ), y as (
    select
      local_ref,
      date_trunc('week', local_ref)::date as current_week_start
    from x
  )
  select
    local_ref,
    current_week_start - 7,
    current_week_start - 1,
    current_week_start - 14,
    current_week_start - 8
  from y;
$$;

create or replace function public.build_weekly_report_payload(
  p_user_id uuid,
  p_week_start date,
  p_week_end date,
  p_tz text default 'Europe/Madrid'
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_prev_week_start date := p_week_start - 7;
  v_prev_week_end date := p_week_start - 1;

  v_habits_week_by_habit jsonb := '[]'::jsonb;
  v_habits_week_done integer := 0;
  v_habits_week_target integer := 0;
  v_habits_week_rate numeric;
  v_habits_prev_week_rate numeric;
  v_habits_week_weakest jsonb;

  v_habits_all_by_habit jsonb := '[]'::jsonb;
  v_habits_all_done integer := 0;
  v_habits_all_target integer := 0;
  v_habits_all_rate numeric;

  v_weight_week_count integer := 0;
  v_weight_week_mean numeric;
  v_weight_week_min numeric;
  v_weight_week_max numeric;
  v_weight_prev_week_mean numeric;
  v_weight_week_change_mean numeric;

  v_weight_all_mean numeric;
  v_weight_first numeric;
  v_weight_last numeric;
  v_weight_change_since_start numeric;

  v_med_week_days_total integer := 7;
  v_med_week_days_completed integer := 0;
  v_med_week_rate numeric;
  v_med_week_total_intakes integer := 0;
  v_med_week_extra_count integer := 0;
  v_med_week_status text := 'red';

  v_med_all_days_total integer := 0;
  v_med_all_days_completed integer := 0;
  v_med_all_rate numeric;
  v_med_all_extra_count integer := 0;
  v_med_all_weeks_with_extra integer := 0;
  v_med_all_extra_weekly_avg numeric;

  v_payload jsonb;
begin
  if p_week_end < p_week_start then
    raise exception 'week_end must be >= week_start';
  end if;

  -- Habits: weekly (per habit + global)
  with habit_base as (
    select
      h.id as habit_id,
      h.name,
      greatest(0, p_week_end - greatest(p_week_start, (h.created_at at time zone p_tz)::date) + 1)::int as target_count,
      coalesce(sum(case when hc.status = 1 then 1 else 0 end), 0)::int as done_count
    from public.habits h
    left join public.habit_checks hc
      on hc.user_id = p_user_id
      and hc.habit_id = h.id
      and hc.log_date between p_week_start and p_week_end
    where h.user_id = p_user_id
      and (h.created_at at time zone p_tz)::date <= p_week_end
    group by h.id, h.name, h.created_at
  ), habit_enriched as (
    select
      habit_id,
      name,
      done_count,
      target_count,
      case when target_count > 0 then done_count::numeric / target_count else null end as completion_rate
    from habit_base
  )
  select
    coalesce(
      jsonb_agg(
        jsonb_build_object(
          'habit_id', habit_id,
          'name', name,
          'done_count', done_count,
          'target_count', target_count,
          'completion_rate', completion_rate
        )
        order by name
      ),
      '[]'::jsonb
    ),
    coalesce(sum(done_count), 0)::int,
    coalesce(sum(target_count), 0)::int,
    case when coalesce(sum(target_count), 0) > 0 then sum(done_count)::numeric / sum(target_count) else null end,
    (
      select jsonb_build_object(
        'habit_id', habit_id,
        'name', name,
        'done_count', done_count,
        'target_count', target_count,
        'completion_rate', completion_rate
      )
      from habit_enriched
      where target_count > 0
      order by completion_rate asc nulls last, done_count asc, name asc
      limit 1
    )
  into
    v_habits_week_by_habit,
    v_habits_week_done,
    v_habits_week_target,
    v_habits_week_rate,
    v_habits_week_weakest
  from habit_enriched;

  -- Habits: previous week global rate
  with habit_base as (
    select
      h.id as habit_id,
      greatest(0, v_prev_week_end - greatest(v_prev_week_start, (h.created_at at time zone p_tz)::date) + 1)::int as target_count,
      coalesce(sum(case when hc.status = 1 then 1 else 0 end), 0)::int as done_count
    from public.habits h
    left join public.habit_checks hc
      on hc.user_id = p_user_id
      and hc.habit_id = h.id
      and hc.log_date between v_prev_week_start and v_prev_week_end
    where h.user_id = p_user_id
      and (h.created_at at time zone p_tz)::date <= v_prev_week_end
    group by h.id, h.created_at
  )
  select
    case when coalesce(sum(target_count), 0) > 0 then sum(done_count)::numeric / sum(target_count) else null end
  into v_habits_prev_week_rate
  from habit_base;

  -- Habits: all time (up to week_end)
  with habit_base as (
    select
      h.id as habit_id,
      h.name,
      greatest(0, p_week_end - (h.created_at at time zone p_tz)::date + 1)::int as target_count,
      (
        select count(*)::int
        from public.habit_checks hc
        where hc.user_id = p_user_id
          and hc.habit_id = h.id
          and hc.status = 1
          and hc.log_date <= p_week_end
      ) as done_count
    from public.habits h
    where h.user_id = p_user_id
      and (h.created_at at time zone p_tz)::date <= p_week_end
  ), habit_enriched as (
    select
      habit_id,
      name,
      done_count,
      target_count,
      case when target_count > 0 then done_count::numeric / target_count else null end as completion_rate
    from habit_base
  )
  select
    coalesce(
      jsonb_agg(
        jsonb_build_object(
          'habit_id', habit_id,
          'name', name,
          'done_count', done_count,
          'target_count', target_count,
          'completion_rate', completion_rate
        )
        order by name
      ),
      '[]'::jsonb
    ),
    coalesce(sum(done_count), 0)::int,
    coalesce(sum(target_count), 0)::int,
    case when coalesce(sum(target_count), 0) > 0 then sum(done_count)::numeric / sum(target_count) else null end
  into
    v_habits_all_by_habit,
    v_habits_all_done,
    v_habits_all_target,
    v_habits_all_rate
  from habit_enriched;

  -- Weight: weekly
  select
    count(*)::int,
    avg(w.weight),
    min(w.weight),
    max(w.weight)
  into
    v_weight_week_count,
    v_weight_week_mean,
    v_weight_week_min,
    v_weight_week_max
  from public.weights w
  where w.user_id = p_user_id
    and ((w.ts at time zone p_tz)::date between p_week_start and p_week_end);

  -- Weight: previous week mean
  select avg(w.weight)
  into v_weight_prev_week_mean
  from public.weights w
  where w.user_id = p_user_id
    and ((w.ts at time zone p_tz)::date between v_prev_week_start and v_prev_week_end);

  if v_weight_week_mean is not null and v_weight_prev_week_mean is not null then
    v_weight_week_change_mean := v_weight_week_mean - v_weight_prev_week_mean;
  else
    v_weight_week_change_mean := null;
  end if;

  -- Weight: all time
  select avg(w.weight)
  into v_weight_all_mean
  from public.weights w
  where w.user_id = p_user_id
    and ((w.ts at time zone p_tz)::date <= p_week_end);

  select w.weight
  into v_weight_first
  from public.weights w
  where w.user_id = p_user_id
    and ((w.ts at time zone p_tz)::date <= p_week_end)
  order by w.ts asc
  limit 1;

  select w.weight
  into v_weight_last
  from public.weights w
  where w.user_id = p_user_id
    and ((w.ts at time zone p_tz)::date <= p_week_end)
  order by w.ts desc
  limit 1;

  if v_weight_first is not null and v_weight_last is not null then
    v_weight_change_since_start := v_weight_last - v_weight_first;
  else
    v_weight_change_since_start := null;
  end if;

  -- Medication: weekly scheduled adherence + extras
  with days as (
    select generate_series(p_week_start::timestamp, p_week_end::timestamp, interval '1 day')::date as day
  ), active_plans as (
    select p.id, p.active_from, coalesce(p.active_to, date '9999-12-31') as active_to
    from public.medication_plans p
    where p.user_id = p_user_id
      and p.type = 'scheduled'
      and p.active_from <= p_week_end
      and (p.active_to is null or p.active_to >= p_week_start)
  ), scheduled_intakes as (
    select distinct i.plan_id, (i.timestamp at time zone p_tz)::date as day
    from public.medication_intakes i
    where i.user_id = p_user_id
      and i.source = 'scheduled'
      and i.plan_id is not null
      and ((i.timestamp at time zone p_tz)::date between p_week_start and p_week_end)
  ), day_stats as (
    select
      d.day,
      (
        select count(*)
        from active_plans ap
        where d.day between ap.active_from and ap.active_to
      )::int as planned_count,
      (
        select count(*)
        from active_plans ap
        join scheduled_intakes si on si.plan_id = ap.id and si.day = d.day
        where d.day between ap.active_from and ap.active_to
      )::int as taken_count
    from days d
  )
  select
    coalesce(sum(case when planned_count > 0 and taken_count >= planned_count then 1 else 0 end), 0)::int
  into v_med_week_days_completed
  from day_stats;

  if v_med_week_days_total > 0 then
    v_med_week_rate := v_med_week_days_completed::numeric / v_med_week_days_total;
  else
    v_med_week_rate := null;
  end if;

  select count(*)::int
  into v_med_week_total_intakes
  from public.medication_intakes i
  where i.user_id = p_user_id
    and ((i.timestamp at time zone p_tz)::date between p_week_start and p_week_end);

  select count(*)::int
  into v_med_week_extra_count
  from public.medication_intakes i
  where i.user_id = p_user_id
    and i.source = 'extra'
    and ((i.timestamp at time zone p_tz)::date between p_week_start and p_week_end);

  if v_med_week_total_intakes = 0 then
    v_med_week_status := 'red';
  elsif coalesce(v_med_week_rate, 0) = 1 then
    v_med_week_status := 'green';
  else
    v_med_week_status := 'orange';
  end if;

  -- Medication: all-time scheduled adherence + extras (up to week_end)
  with first_active as (
    select min(p.active_from) as first_day
    from public.medication_plans p
    where p.user_id = p_user_id
      and p.type = 'scheduled'
      and p.active_from <= p_week_end
  ), days as (
    select generate_series(first_day::timestamp, p_week_end::timestamp, interval '1 day')::date as day
    from first_active
    where first_day is not null
  ), active_plans as (
    select p.id, p.active_from, coalesce(p.active_to, date '9999-12-31') as active_to
    from public.medication_plans p
    where p.user_id = p_user_id
      and p.type = 'scheduled'
      and p.active_from <= p_week_end
  ), scheduled_intakes as (
    select distinct i.plan_id, (i.timestamp at time zone p_tz)::date as day
    from public.medication_intakes i
    where i.user_id = p_user_id
      and i.source = 'scheduled'
      and i.plan_id is not null
      and ((i.timestamp at time zone p_tz)::date <= p_week_end)
  ), day_stats as (
    select
      d.day,
      (
        select count(*)
        from active_plans ap
        where d.day between ap.active_from and ap.active_to
      )::int as planned_count,
      (
        select count(*)
        from active_plans ap
        join scheduled_intakes si on si.plan_id = ap.id and si.day = d.day
        where d.day between ap.active_from and ap.active_to
      )::int as taken_count
    from days d
  )
  select
    coalesce(count(*), 0)::int,
    coalesce(sum(case when planned_count > 0 and taken_count >= planned_count then 1 else 0 end), 0)::int
  into
    v_med_all_days_total,
    v_med_all_days_completed
  from day_stats;

  if v_med_all_days_total > 0 then
    v_med_all_rate := v_med_all_days_completed::numeric / v_med_all_days_total;
  else
    v_med_all_rate := null;
  end if;

  select count(*)::int
  into v_med_all_extra_count
  from public.medication_intakes i
  where i.user_id = p_user_id
    and i.source = 'extra'
    and ((i.timestamp at time zone p_tz)::date <= p_week_end);

  select count(distinct date_trunc('week', i.timestamp at time zone p_tz)::date)::int
  into v_med_all_weeks_with_extra
  from public.medication_intakes i
  where i.user_id = p_user_id
    and i.source = 'extra'
    and ((i.timestamp at time zone p_tz)::date <= p_week_end);

  if coalesce(v_med_all_weeks_with_extra, 0) > 0 then
    v_med_all_extra_weekly_avg := v_med_all_extra_count::numeric / v_med_all_weeks_with_extra;
  else
    v_med_all_extra_weekly_avg := null;
  end if;

  v_payload := jsonb_build_object(
    'meta', jsonb_build_object(
      'timezone', p_tz,
      'week_start', p_week_start,
      'week_end', p_week_end,
      'generated_at', now()
    ),
    'week', jsonb_build_object(
      'habits', jsonb_build_object(
        'by_habit', v_habits_week_by_habit,
        'total_done', v_habits_week_done,
        'total_target', v_habits_week_target,
        'global_rate', v_habits_week_rate,
        'delta_rate', case
          when v_habits_week_rate is null or v_habits_prev_week_rate is null then null
          else v_habits_week_rate - v_habits_prev_week_rate
        end,
        'weakest_habit', v_habits_week_weakest
      ),
      'weight', jsonb_build_object(
        'n_measurements', v_weight_week_count,
        'mean_weight', v_weight_week_mean,
        'min_weight', v_weight_week_min,
        'max_weight', v_weight_week_max,
        'week_change_mean', v_weight_week_change_mean,
        'has_data', v_weight_week_count > 0
      ),
      'medication', jsonb_build_object(
        'days_completed', v_med_week_days_completed,
        'days_total', v_med_week_days_total,
        'adherence_rate', v_med_week_rate,
        'status_color', v_med_week_status,
        'extra_count_week', v_med_week_extra_count
      )
    ),
    'all_time', jsonb_build_object(
      'habits', jsonb_build_object(
        'by_habit', v_habits_all_by_habit,
        'total_done', v_habits_all_done,
        'total_target', v_habits_all_target,
        'global_rate', v_habits_all_rate
      ),
      'weight', jsonb_build_object(
        'mean_weight_all_time', v_weight_all_mean,
        'change_since_start', v_weight_change_since_start,
        'first_weight', v_weight_first,
        'last_weight', v_weight_last
      ),
      'medication', jsonb_build_object(
        'adherence_rate_all_time', v_med_all_rate,
        'days_completed_all_time', v_med_all_days_completed,
        'days_total_all_time', v_med_all_days_total,
        'extra_count_all_time', v_med_all_extra_count,
        'extra_weekly_average', v_med_all_extra_weekly_avg
      )
    )
  );

  return v_payload;
end;
$$;

create or replace function public.build_weekly_report_summary(
  p_payload jsonb
)
returns text
language plpgsql
immutable
as $$
declare
  v_habits_rate numeric := (p_payload #>> '{week,habits,global_rate}')::numeric;
  v_habits_delta numeric := (p_payload #>> '{week,habits,delta_rate}')::numeric;
  v_weak_name text := p_payload #>> '{week,habits,weakest_habit,name}';
  v_weak_done int := coalesce((p_payload #>> '{week,habits,weakest_habit,done_count}')::int, 0);
  v_weak_target int := coalesce((p_payload #>> '{week,habits,weakest_habit,target_count}')::int, 0);

  v_weight_has_data boolean := coalesce((p_payload #>> '{week,weight,has_data}')::boolean, false);
  v_weight_mean numeric := (p_payload #>> '{week,weight,mean_weight}')::numeric;
  v_weight_delta numeric := (p_payload #>> '{week,weight,week_change_mean}')::numeric;

  v_med_rate numeric := (p_payload #>> '{week,medication,adherence_rate}')::numeric;
  v_med_done int := coalesce((p_payload #>> '{week,medication,days_completed}')::int, 0);
  v_med_total int := coalesce((p_payload #>> '{week,medication,days_total}')::int, 0);
  v_med_extra int := coalesce((p_payload #>> '{week,medication,extra_count_week}')::int, 0);

  v_line_habits text;
  v_line_weight text;
  v_line_med text;
  v_delta_label text;
begin
  if v_habits_delta is null then
    v_delta_label := 'sin comparativa';
  elsif v_habits_delta > 0 then
    v_delta_label := format('+%s%% vs anterior', round(v_habits_delta * 100));
  elsif v_habits_delta < 0 then
    v_delta_label := format('%s%% vs anterior', round(v_habits_delta * 100));
  else
    v_delta_label := 'sin cambios vs anterior';
  end if;

  v_line_habits := format(
    'Habitos: %s esta semana (%s). Mas debil: %s (%s/%s).',
    coalesce(format('%s%%', round(v_habits_rate * 100)), 'sin datos'),
    v_delta_label,
    coalesce(v_weak_name, 'n/a'),
    v_weak_done,
    v_weak_target
  );

  if not v_weight_has_data then
    v_line_weight := 'Peso: sin datos de peso esta semana.';
  else
    v_line_weight := format(
      'Peso: media %s kg (%s).',
      round(v_weight_mean::numeric, 2),
      case
        when v_weight_delta is null then 'sin comparativa'
        when v_weight_delta > 0 then format('+%s kg vs semana anterior', round(v_weight_delta::numeric, 2))
        when v_weight_delta < 0 then format('%s kg vs semana anterior', round(v_weight_delta::numeric, 2))
        else 'sin cambios vs semana anterior'
      end
    );
  end if;

  v_line_med := format(
    'Medicacion: adherencia %s (%s/%s). Extras: %s.',
    coalesce(format('%s%%', round(v_med_rate * 100)), 'sin datos'),
    v_med_done,
    v_med_total,
    v_med_extra
  );

  return v_line_habits || E'\n' || v_line_weight || E'\n' || v_line_med;
end;
$$;

create or replace function public.generate_weekly_report_for_user(
  p_user_id uuid,
  p_week_start date,
  p_week_end date,
  p_force boolean default false,
  p_tz text default 'Europe/Madrid'
)
returns table (
  report_id bigint,
  generated_new boolean
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_existing_id bigint;
  v_payload jsonb;
  v_summary text;
begin
  select wr.id
  into v_existing_id
  from public.weekly_reports wr
  where wr.user_id = p_user_id
    and wr.week_start = p_week_start
  limit 1;

  if v_existing_id is not null and not p_force then
    return query select v_existing_id, false;
    return;
  end if;

  v_payload := public.build_weekly_report_payload(p_user_id, p_week_start, p_week_end, p_tz);
  v_summary := public.build_weekly_report_summary(v_payload);

  if v_existing_id is not null then
    update public.weekly_reports
    set
      generated_at = now(),
      week_end = p_week_end,
      payload_json = v_payload,
      summary_text = v_summary
    where id = v_existing_id;

    return query select v_existing_id, true;
    return;
  end if;

  insert into public.weekly_reports (
    user_id,
    generated_at,
    week_start,
    week_end,
    payload_json,
    summary_text
  )
  values (
    p_user_id,
    now(),
    p_week_start,
    p_week_end,
    v_payload,
    v_summary
  )
  returning id into v_existing_id;

  return query select v_existing_id, true;
end;
$$;

create or replace function public.generate_weekly_report_now(
  p_force boolean default false
)
returns table (
  report_id bigint,
  week_start date,
  week_end date,
  generated_new boolean
)
language plpgsql
security definer
set search_path = public
as $$
declare
  v_uid uuid := auth.uid();
  v_week_start date;
  v_week_end date;
  v_generated boolean;
  v_report_id bigint;
begin
  if v_uid is null then
    raise exception 'No autenticado';
  end if;

  select p.week_start, p.week_end
  into v_week_start, v_week_end
  from public.weekly_report_period(now(), 'Europe/Madrid') p;

  select r.report_id, r.generated_new
  into v_report_id, v_generated
  from public.generate_weekly_report_for_user(v_uid, v_week_start, v_week_end, p_force, 'Europe/Madrid') r;

  return query select v_report_id, v_week_start, v_week_end, v_generated;
end;
$$;

create or replace function public.generate_due_weekly_reports(
  p_force boolean default false,
  p_reference timestamptz default now()
)
returns integer
language plpgsql
security definer
set search_path = public
as $$
declare
  v_week_start date;
  v_week_end date;
  v_count integer := 0;
  v_user_id uuid;
begin
  select p.week_start, p.week_end
  into v_week_start, v_week_end
  from public.weekly_report_period(p_reference, 'Europe/Madrid') p;

  for v_user_id in
    select distinct user_id
    from (
      select w.user_id from public.weights w
      union
      select h.user_id from public.habits h
      union
      select m.user_id from public.medications m
      union
      select wr.user_id from public.weekly_reports wr
    ) u
  loop
    perform *
    from public.generate_weekly_report_for_user(v_user_id, v_week_start, v_week_end, p_force, 'Europe/Madrid');
    v_count := v_count + 1;
  end loop;

  return v_count;
end;
$$;

create or replace function public.run_weekly_reports_scheduler()
returns void
language plpgsql
security definer
set search_path = public
as $$
declare
  v_local_now timestamp := now() at time zone 'Europe/Madrid';
begin
  -- Guard so cron timezone/DST does not break the Monday 08:00 Madrid rule.
  if extract(isodow from v_local_now) = 1 and extract(hour from v_local_now) = 8 then
    perform public.generate_due_weekly_reports(false, now());
  end if;
end;
$$;

grant execute on function public.generate_weekly_report_now(boolean) to authenticated;
grant execute on function public.weekly_report_period(timestamptz, text) to authenticated;

-- Requires pg_cron extension on Supabase project.
create extension if not exists pg_cron;

-- Idempotent schedule: remove existing job with same name, then recreate.
do $$
declare
  v_job_id bigint;
begin
  select jobid into v_job_id from cron.job where jobname = 'weekly-reports-madrid-8am-guarded';
  if v_job_id is not null then
    perform cron.unschedule(v_job_id);
  end if;

  -- Every hour at minute 5, guarded by local Madrid time in run_weekly_reports_scheduler().
  perform cron.schedule(
    'weekly-reports-madrid-8am-guarded',
    '5 * * * *',
    $cron$select public.run_weekly_reports_scheduler();$cron$
  );
end $$;

-- Manual test helpers:
-- 1) Generate report for current user: select * from public.generate_weekly_report_now(false);
-- 2) Force regenerate:              select * from public.generate_weekly_report_now(true);
-- 3) Check computed period:         select * from public.weekly_report_period(now(), 'Europe/Madrid');
